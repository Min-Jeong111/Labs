// Файл HeapInt.h
#pragma once // 1
#include <cassert>

class HeapInt
{
private:
    int* heapValue; // 2

public:
    // 3
    inline HeapInt(int val) 
        // 4
        : heapValue(new int{ val })
    {
    }

    inline ~HeapInt()
    {
        // Заметка: delete проверяет на nullptr сам.
        delete heapValue; // 5
    }

    inline int& asRef()
    {
        assert(heapValue != nullptr); // 6
        return *heapValue;
    }

    HeapInt(const HeapInt& hello); // 7
    HeapInt(HeapInt&& hello);
    void operator=(const HeapInt& hello);
    void operator=(HeapInt&& hello);
};

// Файл main.cpp
#include "HeapInt.h"

void constructors()
{
    HeapInt a{5}; // 8
    HeapInt b{a}; // 9
    HeapInt c{std::move(a)}; // 10
    HeapInt d = b; // 11
    HeapInt e = std::move(b); // 12
    d = std::move(c); // 13
    d = e; // 14
}

// Файл HeapInt.cpp
#include "HeapInt.h"

// ... 15


// Q1: Почему поле heapValue (2) приватное?
// A1: Это поле приватное для того, чтобы не иметь к нему прямой доступ и чтобы невозможно было его изменять в другом месте (Обычная инкапсуляция)

// Q2: Что означает этот синтаксис (4)? Как его расписать в теле конструктора?
// A2: Этот синтаксис, насколько я знаю, означает инициализацию мемберов класса
// Вот как это можно было бы реализовать в теле конструктора:
// inline HeapInt(int val) 
// {
//	heapValue = new int {val};
// }

// Q3: Как скомпилировать это с помощью GCC?
// A3: g++ -c main.cpp -o main.exe

// Q4: Зачем (1)? Какую ситуацию это предотвратит?
// A4: "pragma once" - используется чтобы небыло повторных использований заголовочного файла. Чтобы при компиляции, в случае если этот header в других файлах тоже присутствует, компилятор не вызывал его содержимое несколько раз, чтобы не было ошибок.

// Q5: Почему (3) определена как inline?
// A5: "inline", насколько я знаю, используется так как определение этого конструктора - HeapInt, определен в заголовочном файле

// Q6: Как можно обойти ограничение, что конструктор или функция должны быть inline?
// A6: ---

// Q7: Зачем на (6) нужна проверка, если int* не может быть nullptr?
// A7: Если я не ошибаюсь, указатель типа int, если его не инициализировать или он не был явно обнулён, он, вроде бы, всё равно может быть nullptr. А эта проверка (6), нужна для того чтобы небыло проблем при разыменовании указателя

// Q8: Объясните, какой из конструкторов или перегруженных операторов вызовется для (8-14). Какие из них эквивалентны?
// A8: 8 - Конструктор по умолчанию. Создаётся объект a, и поле heapValue инициализируется 5-кой
//     9 - Конструктор копирования. Создаётся объект b, и в него копируются значения из a
//     10 - Конструктор перемещения. Создаётся объект c, и в него перемещаются значения полей из a, при этом значение в объекте a обнуляется (становится nullptr)
//     11 - В этом случае, вроде, как в 9, тоже вызывается конструктор копирования (эквивалентен 9).
//     12 - Тоже самое как в 10, конструктор перемещения (Эквивалентен 10), 
//     13 - Вызов оператора перемещающего присваивание. Объект d освобождается, и перенимает значения из c.
//     14 - Вызов оператора который копирует присваивания. Объект d освобождается и копирует значения из e.

// Q9: Как запретить синтаксис на (11-12)?
// A9: Запретить можно используя слово "explicit", перед названием конструктора. Это предотвратит случайный неявный вызов конструктора в коде. К примеру, теперь нельзя просто взять и написать "d = b;" , если написать explicit перед HeapInt. 

// Q10: В какой еще ситуации вызовется rvalue reference перегрузка конструктора или оператора присваивания?
// A10 Вроде как, в тех ситуации если есть временный объект, который передаётся параметром в функцию. 

// Q11: Сколько раз вызовется деструктор для типа HeapInt после (14)?
// A11: Как я посчитал, будут вызваны 5 деконструкторов для объектов типа HeapInt

// Q12: Объясните, какая по вашему мнению была мотивация того, что у этого типа не был определен дефолтный конструктор?
// A12: ---

// Q13: Объясните, почему считывать значение объекта после применения std::move это неправильная операция?
// A13: Неправильно, потому-что объект, после перемещения, по сути становится пустым (nullptr). Обращение к пустому объекту и попытке что-то считать может вызвать ошибку

// Q14: Создайте функцию void swap(HeapInt& a, HeapInt& b), которая меняет значения, без выделения новой динамической памяти.
// A14: 
// void swap (HeapInt& a, HeapInt& b)
// {
//	std::swap(a.heapValue, b.heapValue);
// }